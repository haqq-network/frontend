// Since: cosmos-sdk 0.43

// @generated by protoc-gen-es v1.3.1 with parameter "target=ts"
// @generated from file cosmos/base/reflection/v2alpha1/reflection.proto (package cosmos.base.reflection.v2alpha1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * AppDescriptor describes a cosmos-sdk based application
 *
 * @generated from message cosmos.base.reflection.v2alpha1.AppDescriptor
 */
export class AppDescriptor extends Message<AppDescriptor> {
  /**
   * AuthnDescriptor provides information on how to authenticate transactions on the application
   * NOTE: experimental and subject to change in future releases.
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.AuthnDescriptor authn = 1;
   */
  authn?: AuthnDescriptor;

  /**
   * chain provides the chain descriptor
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.ChainDescriptor chain = 2;
   */
  chain?: ChainDescriptor;

  /**
   * codec provides metadata information regarding codec related types
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.CodecDescriptor codec = 3;
   */
  codec?: CodecDescriptor;

  /**
   * configuration provides metadata information regarding the sdk.Config type
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.ConfigurationDescriptor configuration = 4;
   */
  configuration?: ConfigurationDescriptor;

  /**
   * query_services provides metadata information regarding the available queriable endpoints
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.QueryServicesDescriptor query_services = 5;
   */
  queryServices?: QueryServicesDescriptor;

  /**
   * tx provides metadata information regarding how to send transactions to the given application
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.TxDescriptor tx = 6;
   */
  tx?: TxDescriptor;

  constructor(data?: PartialMessage<AppDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.AppDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authn", kind: "message", T: AuthnDescriptor },
    { no: 2, name: "chain", kind: "message", T: ChainDescriptor },
    { no: 3, name: "codec", kind: "message", T: CodecDescriptor },
    { no: 4, name: "configuration", kind: "message", T: ConfigurationDescriptor },
    { no: 5, name: "query_services", kind: "message", T: QueryServicesDescriptor },
    { no: 6, name: "tx", kind: "message", T: TxDescriptor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AppDescriptor {
    return new AppDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AppDescriptor {
    return new AppDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AppDescriptor {
    return new AppDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: AppDescriptor | PlainMessage<AppDescriptor> | undefined, b: AppDescriptor | PlainMessage<AppDescriptor> | undefined): boolean {
    return proto3.util.equals(AppDescriptor, a, b);
  }
}

/**
 * TxDescriptor describes the accepted transaction type
 *
 * @generated from message cosmos.base.reflection.v2alpha1.TxDescriptor
 */
export class TxDescriptor extends Message<TxDescriptor> {
  /**
   * fullname is the protobuf fullname of the raw transaction type (for instance the tx.Tx type)
   * it is not meant to support polymorphism of transaction types, it is supposed to be used by
   * reflection clients to understand if they can handle a specific transaction type in an application.
   *
   * @generated from field: string fullname = 1;
   */
  fullname = "";

  /**
   * msgs lists the accepted application messages (sdk.Msg)
   *
   * @generated from field: repeated cosmos.base.reflection.v2alpha1.MsgDescriptor msgs = 2;
   */
  msgs: MsgDescriptor[] = [];

  constructor(data?: PartialMessage<TxDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.TxDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fullname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "msgs", kind: "message", T: MsgDescriptor, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TxDescriptor {
    return new TxDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TxDescriptor {
    return new TxDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TxDescriptor {
    return new TxDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: TxDescriptor | PlainMessage<TxDescriptor> | undefined, b: TxDescriptor | PlainMessage<TxDescriptor> | undefined): boolean {
    return proto3.util.equals(TxDescriptor, a, b);
  }
}

/**
 * AuthnDescriptor provides information on how to sign transactions without relying
 * on the online RPCs GetTxMetadata and CombineUnsignedTxAndSignatures
 *
 * @generated from message cosmos.base.reflection.v2alpha1.AuthnDescriptor
 */
export class AuthnDescriptor extends Message<AuthnDescriptor> {
  /**
   * sign_modes defines the supported signature algorithm
   *
   * @generated from field: repeated cosmos.base.reflection.v2alpha1.SigningModeDescriptor sign_modes = 1;
   */
  signModes: SigningModeDescriptor[] = [];

  constructor(data?: PartialMessage<AuthnDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.AuthnDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sign_modes", kind: "message", T: SigningModeDescriptor, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AuthnDescriptor {
    return new AuthnDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AuthnDescriptor {
    return new AuthnDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AuthnDescriptor {
    return new AuthnDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: AuthnDescriptor | PlainMessage<AuthnDescriptor> | undefined, b: AuthnDescriptor | PlainMessage<AuthnDescriptor> | undefined): boolean {
    return proto3.util.equals(AuthnDescriptor, a, b);
  }
}

/**
 * SigningModeDescriptor provides information on a signing flow of the application
 * NOTE(fdymylja): here we could go as far as providing an entire flow on how
 * to sign a message given a SigningModeDescriptor, but it's better to think about
 * this another time
 *
 * @generated from message cosmos.base.reflection.v2alpha1.SigningModeDescriptor
 */
export class SigningModeDescriptor extends Message<SigningModeDescriptor> {
  /**
   * name defines the unique name of the signing mode
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * number is the unique int32 identifier for the sign_mode enum
   *
   * @generated from field: int32 number = 2;
   */
  number = 0;

  /**
   * authn_info_provider_method_fullname defines the fullname of the method to call to get
   * the metadata required to authenticate using the provided sign_modes
   *
   * @generated from field: string authn_info_provider_method_fullname = 3;
   */
  authnInfoProviderMethodFullname = "";

  constructor(data?: PartialMessage<SigningModeDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.SigningModeDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "number", kind: "scalar", T: 5 /* ScalarType.INT32 */ },
    { no: 3, name: "authn_info_provider_method_fullname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): SigningModeDescriptor {
    return new SigningModeDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): SigningModeDescriptor {
    return new SigningModeDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): SigningModeDescriptor {
    return new SigningModeDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: SigningModeDescriptor | PlainMessage<SigningModeDescriptor> | undefined, b: SigningModeDescriptor | PlainMessage<SigningModeDescriptor> | undefined): boolean {
    return proto3.util.equals(SigningModeDescriptor, a, b);
  }
}

/**
 * ChainDescriptor describes chain information of the application
 *
 * @generated from message cosmos.base.reflection.v2alpha1.ChainDescriptor
 */
export class ChainDescriptor extends Message<ChainDescriptor> {
  /**
   * id is the chain id
   *
   * @generated from field: string id = 1;
   */
  id = "";

  constructor(data?: PartialMessage<ChainDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.ChainDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ChainDescriptor {
    return new ChainDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ChainDescriptor {
    return new ChainDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ChainDescriptor {
    return new ChainDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: ChainDescriptor | PlainMessage<ChainDescriptor> | undefined, b: ChainDescriptor | PlainMessage<ChainDescriptor> | undefined): boolean {
    return proto3.util.equals(ChainDescriptor, a, b);
  }
}

/**
 * CodecDescriptor describes the registered interfaces and provides metadata information on the types
 *
 * @generated from message cosmos.base.reflection.v2alpha1.CodecDescriptor
 */
export class CodecDescriptor extends Message<CodecDescriptor> {
  /**
   * interfaces is a list of the registerted interfaces descriptors
   *
   * @generated from field: repeated cosmos.base.reflection.v2alpha1.InterfaceDescriptor interfaces = 1;
   */
  interfaces: InterfaceDescriptor[] = [];

  constructor(data?: PartialMessage<CodecDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.CodecDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "interfaces", kind: "message", T: InterfaceDescriptor, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): CodecDescriptor {
    return new CodecDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): CodecDescriptor {
    return new CodecDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): CodecDescriptor {
    return new CodecDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: CodecDescriptor | PlainMessage<CodecDescriptor> | undefined, b: CodecDescriptor | PlainMessage<CodecDescriptor> | undefined): boolean {
    return proto3.util.equals(CodecDescriptor, a, b);
  }
}

/**
 * InterfaceDescriptor describes the implementation of an interface
 *
 * @generated from message cosmos.base.reflection.v2alpha1.InterfaceDescriptor
 */
export class InterfaceDescriptor extends Message<InterfaceDescriptor> {
  /**
   * fullname is the name of the interface
   *
   * @generated from field: string fullname = 1;
   */
  fullname = "";

  /**
   * interface_accepting_messages contains information regarding the proto messages which contain the interface as
   * google.protobuf.Any field
   *
   * @generated from field: repeated cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor interface_accepting_messages = 2;
   */
  interfaceAcceptingMessages: InterfaceAcceptingMessageDescriptor[] = [];

  /**
   * interface_implementers is a list of the descriptors of the interface implementers
   *
   * @generated from field: repeated cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor interface_implementers = 3;
   */
  interfaceImplementers: InterfaceImplementerDescriptor[] = [];

  constructor(data?: PartialMessage<InterfaceDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.InterfaceDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fullname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "interface_accepting_messages", kind: "message", T: InterfaceAcceptingMessageDescriptor, repeated: true },
    { no: 3, name: "interface_implementers", kind: "message", T: InterfaceImplementerDescriptor, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InterfaceDescriptor {
    return new InterfaceDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InterfaceDescriptor {
    return new InterfaceDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InterfaceDescriptor {
    return new InterfaceDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: InterfaceDescriptor | PlainMessage<InterfaceDescriptor> | undefined, b: InterfaceDescriptor | PlainMessage<InterfaceDescriptor> | undefined): boolean {
    return proto3.util.equals(InterfaceDescriptor, a, b);
  }
}

/**
 * InterfaceImplementerDescriptor describes an interface implementer
 *
 * @generated from message cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor
 */
export class InterfaceImplementerDescriptor extends Message<InterfaceImplementerDescriptor> {
  /**
   * fullname is the protobuf queryable name of the interface implementer
   *
   * @generated from field: string fullname = 1;
   */
  fullname = "";

  /**
   * type_url defines the type URL used when marshalling the type as any
   * this is required so we can provide type safe google.protobuf.Any marshalling and
   * unmarshalling, making sure that we don't accept just 'any' type
   * in our interface fields
   *
   * @generated from field: string type_url = 2;
   */
  typeUrl = "";

  constructor(data?: PartialMessage<InterfaceImplementerDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.InterfaceImplementerDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fullname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "type_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InterfaceImplementerDescriptor {
    return new InterfaceImplementerDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InterfaceImplementerDescriptor {
    return new InterfaceImplementerDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InterfaceImplementerDescriptor {
    return new InterfaceImplementerDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: InterfaceImplementerDescriptor | PlainMessage<InterfaceImplementerDescriptor> | undefined, b: InterfaceImplementerDescriptor | PlainMessage<InterfaceImplementerDescriptor> | undefined): boolean {
    return proto3.util.equals(InterfaceImplementerDescriptor, a, b);
  }
}

/**
 * InterfaceAcceptingMessageDescriptor describes a protobuf message which contains
 * an interface represented as a google.protobuf.Any
 *
 * @generated from message cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor
 */
export class InterfaceAcceptingMessageDescriptor extends Message<InterfaceAcceptingMessageDescriptor> {
  /**
   * fullname is the protobuf fullname of the type containing the interface
   *
   * @generated from field: string fullname = 1;
   */
  fullname = "";

  /**
   * field_descriptor_names is a list of the protobuf name (not fullname) of the field
   * which contains the interface as google.protobuf.Any (the interface is the same, but
   * it can be in multiple fields of the same proto message)
   *
   * @generated from field: repeated string field_descriptor_names = 2;
   */
  fieldDescriptorNames: string[] = [];

  constructor(data?: PartialMessage<InterfaceAcceptingMessageDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.InterfaceAcceptingMessageDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fullname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "field_descriptor_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): InterfaceAcceptingMessageDescriptor {
    return new InterfaceAcceptingMessageDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): InterfaceAcceptingMessageDescriptor {
    return new InterfaceAcceptingMessageDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): InterfaceAcceptingMessageDescriptor {
    return new InterfaceAcceptingMessageDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: InterfaceAcceptingMessageDescriptor | PlainMessage<InterfaceAcceptingMessageDescriptor> | undefined, b: InterfaceAcceptingMessageDescriptor | PlainMessage<InterfaceAcceptingMessageDescriptor> | undefined): boolean {
    return proto3.util.equals(InterfaceAcceptingMessageDescriptor, a, b);
  }
}

/**
 * ConfigurationDescriptor contains metadata information on the sdk.Config
 *
 * @generated from message cosmos.base.reflection.v2alpha1.ConfigurationDescriptor
 */
export class ConfigurationDescriptor extends Message<ConfigurationDescriptor> {
  /**
   * bech32_account_address_prefix is the account address prefix
   *
   * @generated from field: string bech32_account_address_prefix = 1;
   */
  bech32AccountAddressPrefix = "";

  constructor(data?: PartialMessage<ConfigurationDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.ConfigurationDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bech32_account_address_prefix", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ConfigurationDescriptor {
    return new ConfigurationDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ConfigurationDescriptor {
    return new ConfigurationDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ConfigurationDescriptor {
    return new ConfigurationDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: ConfigurationDescriptor | PlainMessage<ConfigurationDescriptor> | undefined, b: ConfigurationDescriptor | PlainMessage<ConfigurationDescriptor> | undefined): boolean {
    return proto3.util.equals(ConfigurationDescriptor, a, b);
  }
}

/**
 * MsgDescriptor describes a cosmos-sdk message that can be delivered with a transaction
 *
 * @generated from message cosmos.base.reflection.v2alpha1.MsgDescriptor
 */
export class MsgDescriptor extends Message<MsgDescriptor> {
  /**
   * msg_type_url contains the TypeURL of a sdk.Msg.
   *
   * @generated from field: string msg_type_url = 1;
   */
  msgTypeUrl = "";

  constructor(data?: PartialMessage<MsgDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.MsgDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "msg_type_url", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): MsgDescriptor {
    return new MsgDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): MsgDescriptor {
    return new MsgDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): MsgDescriptor {
    return new MsgDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: MsgDescriptor | PlainMessage<MsgDescriptor> | undefined, b: MsgDescriptor | PlainMessage<MsgDescriptor> | undefined): boolean {
    return proto3.util.equals(MsgDescriptor, a, b);
  }
}

/**
 * GetAuthnDescriptorRequest is the request used for the GetAuthnDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetAuthnDescriptorRequest
 */
export class GetAuthnDescriptorRequest extends Message<GetAuthnDescriptorRequest> {
  constructor(data?: PartialMessage<GetAuthnDescriptorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetAuthnDescriptorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAuthnDescriptorRequest {
    return new GetAuthnDescriptorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAuthnDescriptorRequest {
    return new GetAuthnDescriptorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAuthnDescriptorRequest {
    return new GetAuthnDescriptorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetAuthnDescriptorRequest | PlainMessage<GetAuthnDescriptorRequest> | undefined, b: GetAuthnDescriptorRequest | PlainMessage<GetAuthnDescriptorRequest> | undefined): boolean {
    return proto3.util.equals(GetAuthnDescriptorRequest, a, b);
  }
}

/**
 * GetAuthnDescriptorResponse is the response returned by the GetAuthnDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetAuthnDescriptorResponse
 */
export class GetAuthnDescriptorResponse extends Message<GetAuthnDescriptorResponse> {
  /**
   * authn describes how to authenticate to the application when sending transactions
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.AuthnDescriptor authn = 1;
   */
  authn?: AuthnDescriptor;

  constructor(data?: PartialMessage<GetAuthnDescriptorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetAuthnDescriptorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "authn", kind: "message", T: AuthnDescriptor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetAuthnDescriptorResponse {
    return new GetAuthnDescriptorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetAuthnDescriptorResponse {
    return new GetAuthnDescriptorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetAuthnDescriptorResponse {
    return new GetAuthnDescriptorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetAuthnDescriptorResponse | PlainMessage<GetAuthnDescriptorResponse> | undefined, b: GetAuthnDescriptorResponse | PlainMessage<GetAuthnDescriptorResponse> | undefined): boolean {
    return proto3.util.equals(GetAuthnDescriptorResponse, a, b);
  }
}

/**
 * GetChainDescriptorRequest is the request used for the GetChainDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetChainDescriptorRequest
 */
export class GetChainDescriptorRequest extends Message<GetChainDescriptorRequest> {
  constructor(data?: PartialMessage<GetChainDescriptorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetChainDescriptorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChainDescriptorRequest {
    return new GetChainDescriptorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChainDescriptorRequest {
    return new GetChainDescriptorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChainDescriptorRequest {
    return new GetChainDescriptorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetChainDescriptorRequest | PlainMessage<GetChainDescriptorRequest> | undefined, b: GetChainDescriptorRequest | PlainMessage<GetChainDescriptorRequest> | undefined): boolean {
    return proto3.util.equals(GetChainDescriptorRequest, a, b);
  }
}

/**
 * GetChainDescriptorResponse is the response returned by the GetChainDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse
 */
export class GetChainDescriptorResponse extends Message<GetChainDescriptorResponse> {
  /**
   * chain describes application chain information
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.ChainDescriptor chain = 1;
   */
  chain?: ChainDescriptor;

  constructor(data?: PartialMessage<GetChainDescriptorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetChainDescriptorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "chain", kind: "message", T: ChainDescriptor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetChainDescriptorResponse {
    return new GetChainDescriptorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetChainDescriptorResponse {
    return new GetChainDescriptorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetChainDescriptorResponse {
    return new GetChainDescriptorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetChainDescriptorResponse | PlainMessage<GetChainDescriptorResponse> | undefined, b: GetChainDescriptorResponse | PlainMessage<GetChainDescriptorResponse> | undefined): boolean {
    return proto3.util.equals(GetChainDescriptorResponse, a, b);
  }
}

/**
 * GetCodecDescriptorRequest is the request used for the GetCodecDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetCodecDescriptorRequest
 */
export class GetCodecDescriptorRequest extends Message<GetCodecDescriptorRequest> {
  constructor(data?: PartialMessage<GetCodecDescriptorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetCodecDescriptorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCodecDescriptorRequest {
    return new GetCodecDescriptorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCodecDescriptorRequest {
    return new GetCodecDescriptorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCodecDescriptorRequest {
    return new GetCodecDescriptorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetCodecDescriptorRequest | PlainMessage<GetCodecDescriptorRequest> | undefined, b: GetCodecDescriptorRequest | PlainMessage<GetCodecDescriptorRequest> | undefined): boolean {
    return proto3.util.equals(GetCodecDescriptorRequest, a, b);
  }
}

/**
 * GetCodecDescriptorResponse is the response returned by the GetCodecDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetCodecDescriptorResponse
 */
export class GetCodecDescriptorResponse extends Message<GetCodecDescriptorResponse> {
  /**
   * codec describes the application codec such as registered interfaces and implementations
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.CodecDescriptor codec = 1;
   */
  codec?: CodecDescriptor;

  constructor(data?: PartialMessage<GetCodecDescriptorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetCodecDescriptorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "codec", kind: "message", T: CodecDescriptor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetCodecDescriptorResponse {
    return new GetCodecDescriptorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetCodecDescriptorResponse {
    return new GetCodecDescriptorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetCodecDescriptorResponse {
    return new GetCodecDescriptorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetCodecDescriptorResponse | PlainMessage<GetCodecDescriptorResponse> | undefined, b: GetCodecDescriptorResponse | PlainMessage<GetCodecDescriptorResponse> | undefined): boolean {
    return proto3.util.equals(GetCodecDescriptorResponse, a, b);
  }
}

/**
 * GetConfigurationDescriptorRequest is the request used for the GetConfigurationDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorRequest
 */
export class GetConfigurationDescriptorRequest extends Message<GetConfigurationDescriptorRequest> {
  constructor(data?: PartialMessage<GetConfigurationDescriptorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigurationDescriptorRequest {
    return new GetConfigurationDescriptorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigurationDescriptorRequest {
    return new GetConfigurationDescriptorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigurationDescriptorRequest {
    return new GetConfigurationDescriptorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigurationDescriptorRequest | PlainMessage<GetConfigurationDescriptorRequest> | undefined, b: GetConfigurationDescriptorRequest | PlainMessage<GetConfigurationDescriptorRequest> | undefined): boolean {
    return proto3.util.equals(GetConfigurationDescriptorRequest, a, b);
  }
}

/**
 * GetConfigurationDescriptorResponse is the response returned by the GetConfigurationDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorResponse
 */
export class GetConfigurationDescriptorResponse extends Message<GetConfigurationDescriptorResponse> {
  /**
   * config describes the application's sdk.Config
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.ConfigurationDescriptor config = 1;
   */
  config?: ConfigurationDescriptor;

  constructor(data?: PartialMessage<GetConfigurationDescriptorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetConfigurationDescriptorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "config", kind: "message", T: ConfigurationDescriptor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetConfigurationDescriptorResponse {
    return new GetConfigurationDescriptorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetConfigurationDescriptorResponse {
    return new GetConfigurationDescriptorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetConfigurationDescriptorResponse {
    return new GetConfigurationDescriptorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetConfigurationDescriptorResponse | PlainMessage<GetConfigurationDescriptorResponse> | undefined, b: GetConfigurationDescriptorResponse | PlainMessage<GetConfigurationDescriptorResponse> | undefined): boolean {
    return proto3.util.equals(GetConfigurationDescriptorResponse, a, b);
  }
}

/**
 * GetQueryServicesDescriptorRequest is the request used for the GetQueryServicesDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorRequest
 */
export class GetQueryServicesDescriptorRequest extends Message<GetQueryServicesDescriptorRequest> {
  constructor(data?: PartialMessage<GetQueryServicesDescriptorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetQueryServicesDescriptorRequest {
    return new GetQueryServicesDescriptorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetQueryServicesDescriptorRequest {
    return new GetQueryServicesDescriptorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetQueryServicesDescriptorRequest {
    return new GetQueryServicesDescriptorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetQueryServicesDescriptorRequest | PlainMessage<GetQueryServicesDescriptorRequest> | undefined, b: GetQueryServicesDescriptorRequest | PlainMessage<GetQueryServicesDescriptorRequest> | undefined): boolean {
    return proto3.util.equals(GetQueryServicesDescriptorRequest, a, b);
  }
}

/**
 * GetQueryServicesDescriptorResponse is the response returned by the GetQueryServicesDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse
 */
export class GetQueryServicesDescriptorResponse extends Message<GetQueryServicesDescriptorResponse> {
  /**
   * queries provides information on the available queryable services
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.QueryServicesDescriptor queries = 1;
   */
  queries?: QueryServicesDescriptor;

  constructor(data?: PartialMessage<GetQueryServicesDescriptorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetQueryServicesDescriptorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "queries", kind: "message", T: QueryServicesDescriptor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetQueryServicesDescriptorResponse {
    return new GetQueryServicesDescriptorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetQueryServicesDescriptorResponse {
    return new GetQueryServicesDescriptorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetQueryServicesDescriptorResponse {
    return new GetQueryServicesDescriptorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetQueryServicesDescriptorResponse | PlainMessage<GetQueryServicesDescriptorResponse> | undefined, b: GetQueryServicesDescriptorResponse | PlainMessage<GetQueryServicesDescriptorResponse> | undefined): boolean {
    return proto3.util.equals(GetQueryServicesDescriptorResponse, a, b);
  }
}

/**
 * GetTxDescriptorRequest is the request used for the GetTxDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetTxDescriptorRequest
 */
export class GetTxDescriptorRequest extends Message<GetTxDescriptorRequest> {
  constructor(data?: PartialMessage<GetTxDescriptorRequest>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetTxDescriptorRequest";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTxDescriptorRequest {
    return new GetTxDescriptorRequest().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTxDescriptorRequest {
    return new GetTxDescriptorRequest().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTxDescriptorRequest {
    return new GetTxDescriptorRequest().fromJsonString(jsonString, options);
  }

  static equals(a: GetTxDescriptorRequest | PlainMessage<GetTxDescriptorRequest> | undefined, b: GetTxDescriptorRequest | PlainMessage<GetTxDescriptorRequest> | undefined): boolean {
    return proto3.util.equals(GetTxDescriptorRequest, a, b);
  }
}

/**
 * GetTxDescriptorResponse is the response returned by the GetTxDescriptor RPC
 *
 * @generated from message cosmos.base.reflection.v2alpha1.GetTxDescriptorResponse
 */
export class GetTxDescriptorResponse extends Message<GetTxDescriptorResponse> {
  /**
   * tx provides information on msgs that can be forwarded to the application
   * alongside the accepted transaction protobuf type
   *
   * @generated from field: cosmos.base.reflection.v2alpha1.TxDescriptor tx = 1;
   */
  tx?: TxDescriptor;

  constructor(data?: PartialMessage<GetTxDescriptorResponse>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.GetTxDescriptorResponse";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tx", kind: "message", T: TxDescriptor },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): GetTxDescriptorResponse {
    return new GetTxDescriptorResponse().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): GetTxDescriptorResponse {
    return new GetTxDescriptorResponse().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): GetTxDescriptorResponse {
    return new GetTxDescriptorResponse().fromJsonString(jsonString, options);
  }

  static equals(a: GetTxDescriptorResponse | PlainMessage<GetTxDescriptorResponse> | undefined, b: GetTxDescriptorResponse | PlainMessage<GetTxDescriptorResponse> | undefined): boolean {
    return proto3.util.equals(GetTxDescriptorResponse, a, b);
  }
}

/**
 * QueryServicesDescriptor contains the list of cosmos-sdk queriable services
 *
 * @generated from message cosmos.base.reflection.v2alpha1.QueryServicesDescriptor
 */
export class QueryServicesDescriptor extends Message<QueryServicesDescriptor> {
  /**
   * query_services is a list of cosmos-sdk QueryServiceDescriptor
   *
   * @generated from field: repeated cosmos.base.reflection.v2alpha1.QueryServiceDescriptor query_services = 1;
   */
  queryServices: QueryServiceDescriptor[] = [];

  constructor(data?: PartialMessage<QueryServicesDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.QueryServicesDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "query_services", kind: "message", T: QueryServiceDescriptor, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryServicesDescriptor {
    return new QueryServicesDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryServicesDescriptor {
    return new QueryServicesDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryServicesDescriptor {
    return new QueryServicesDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: QueryServicesDescriptor | PlainMessage<QueryServicesDescriptor> | undefined, b: QueryServicesDescriptor | PlainMessage<QueryServicesDescriptor> | undefined): boolean {
    return proto3.util.equals(QueryServicesDescriptor, a, b);
  }
}

/**
 * QueryServiceDescriptor describes a cosmos-sdk queryable service
 *
 * @generated from message cosmos.base.reflection.v2alpha1.QueryServiceDescriptor
 */
export class QueryServiceDescriptor extends Message<QueryServiceDescriptor> {
  /**
   * fullname is the protobuf fullname of the service descriptor
   *
   * @generated from field: string fullname = 1;
   */
  fullname = "";

  /**
   * is_module describes if this service is actually exposed by an application's module
   *
   * @generated from field: bool is_module = 2;
   */
  isModule = false;

  /**
   * methods provides a list of query service methods
   *
   * @generated from field: repeated cosmos.base.reflection.v2alpha1.QueryMethodDescriptor methods = 3;
   */
  methods: QueryMethodDescriptor[] = [];

  constructor(data?: PartialMessage<QueryServiceDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.QueryServiceDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "fullname", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "is_module", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "methods", kind: "message", T: QueryMethodDescriptor, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryServiceDescriptor {
    return new QueryServiceDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryServiceDescriptor {
    return new QueryServiceDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryServiceDescriptor {
    return new QueryServiceDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: QueryServiceDescriptor | PlainMessage<QueryServiceDescriptor> | undefined, b: QueryServiceDescriptor | PlainMessage<QueryServiceDescriptor> | undefined): boolean {
    return proto3.util.equals(QueryServiceDescriptor, a, b);
  }
}

/**
 * QueryMethodDescriptor describes a queryable method of a query service
 * no other info is provided beside method name and tendermint queryable path
 * because it would be redundant with the grpc reflection service
 *
 * @generated from message cosmos.base.reflection.v2alpha1.QueryMethodDescriptor
 */
export class QueryMethodDescriptor extends Message<QueryMethodDescriptor> {
  /**
   * name is the protobuf name (not fullname) of the method
   *
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * full_query_path is the path that can be used to query
   * this method via tendermint abci.Query
   *
   * @generated from field: string full_query_path = 2;
   */
  fullQueryPath = "";

  constructor(data?: PartialMessage<QueryMethodDescriptor>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = "cosmos.base.reflection.v2alpha1.QueryMethodDescriptor";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "full_query_path", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): QueryMethodDescriptor {
    return new QueryMethodDescriptor().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): QueryMethodDescriptor {
    return new QueryMethodDescriptor().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): QueryMethodDescriptor {
    return new QueryMethodDescriptor().fromJsonString(jsonString, options);
  }

  static equals(a: QueryMethodDescriptor | PlainMessage<QueryMethodDescriptor> | undefined, b: QueryMethodDescriptor | PlainMessage<QueryMethodDescriptor> | undefined): boolean {
    return proto3.util.equals(QueryMethodDescriptor, a, b);
  }
}


// @generated by protoc-gen-es v1.3.1 with parameter "target=ts"
// @generated from file ibc/core/client/v1/client.proto (package ibc.core.client.v1, syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type {
  BinaryReadOptions,
  FieldList,
  JsonReadOptions,
  JsonValue,
  PartialMessage,
  PlainMessage,
} from '@bufbuild/protobuf';
import { Any, Message, proto3, protoInt64 } from '@bufbuild/protobuf';
import { Plan } from '../../../../cosmos/upgrade/v1beta1/upgrade_pb';

/**
 * IdentifiedClientState defines a client state with an additional client
 * identifier field.
 *
 * @generated from message ibc.core.client.v1.IdentifiedClientState
 */
export class IdentifiedClientState extends Message<IdentifiedClientState> {
  /**
   * client identifier
   *
   * @generated from field: string client_id = 1;
   */
  clientId = '';

  /**
   * client state
   *
   * @generated from field: google.protobuf.Any client_state = 2;
   */
  clientState?: Any;

  constructor(data?: PartialMessage<IdentifiedClientState>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'ibc.core.client.v1.IdentifiedClientState';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'client_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    { no: 2, name: 'client_state', kind: 'message', T: Any },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): IdentifiedClientState {
    return new IdentifiedClientState().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): IdentifiedClientState {
    return new IdentifiedClientState().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): IdentifiedClientState {
    return new IdentifiedClientState().fromJsonString(jsonString, options);
  }

  static equals(
    a: IdentifiedClientState | PlainMessage<IdentifiedClientState> | undefined,
    b: IdentifiedClientState | PlainMessage<IdentifiedClientState> | undefined,
  ): boolean {
    return proto3.util.equals(IdentifiedClientState, a, b);
  }
}

/**
 * ConsensusStateWithHeight defines a consensus state with an additional height
 * field.
 *
 * @generated from message ibc.core.client.v1.ConsensusStateWithHeight
 */
export class ConsensusStateWithHeight extends Message<ConsensusStateWithHeight> {
  /**
   * consensus state height
   *
   * @generated from field: ibc.core.client.v1.Height height = 1;
   */
  height?: Height;

  /**
   * consensus state
   *
   * @generated from field: google.protobuf.Any consensus_state = 2;
   */
  consensusState?: Any;

  constructor(data?: PartialMessage<ConsensusStateWithHeight>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'ibc.core.client.v1.ConsensusStateWithHeight';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'height', kind: 'message', T: Height },
    { no: 2, name: 'consensus_state', kind: 'message', T: Any },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ConsensusStateWithHeight {
    return new ConsensusStateWithHeight().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): ConsensusStateWithHeight {
    return new ConsensusStateWithHeight().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ConsensusStateWithHeight {
    return new ConsensusStateWithHeight().fromJsonString(jsonString, options);
  }

  static equals(
    a:
      | ConsensusStateWithHeight
      | PlainMessage<ConsensusStateWithHeight>
      | undefined,
    b:
      | ConsensusStateWithHeight
      | PlainMessage<ConsensusStateWithHeight>
      | undefined,
  ): boolean {
    return proto3.util.equals(ConsensusStateWithHeight, a, b);
  }
}

/**
 * ClientConsensusStates defines all the stored consensus states for a given
 * client.
 *
 * @generated from message ibc.core.client.v1.ClientConsensusStates
 */
export class ClientConsensusStates extends Message<ClientConsensusStates> {
  /**
   * client identifier
   *
   * @generated from field: string client_id = 1;
   */
  clientId = '';

  /**
   * consensus states and their heights associated with the client
   *
   * @generated from field: repeated ibc.core.client.v1.ConsensusStateWithHeight consensus_states = 2;
   */
  consensusStates: ConsensusStateWithHeight[] = [];

  constructor(data?: PartialMessage<ClientConsensusStates>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'ibc.core.client.v1.ClientConsensusStates';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'client_id', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    {
      no: 2,
      name: 'consensus_states',
      kind: 'message',
      T: ConsensusStateWithHeight,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ClientConsensusStates {
    return new ClientConsensusStates().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): ClientConsensusStates {
    return new ClientConsensusStates().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ClientConsensusStates {
    return new ClientConsensusStates().fromJsonString(jsonString, options);
  }

  static equals(
    a: ClientConsensusStates | PlainMessage<ClientConsensusStates> | undefined,
    b: ClientConsensusStates | PlainMessage<ClientConsensusStates> | undefined,
  ): boolean {
    return proto3.util.equals(ClientConsensusStates, a, b);
  }
}

/**
 * ClientUpdateProposal is a governance proposal. If it passes, the substitute
 * client's latest consensus state is copied over to the subject client. The proposal
 * handler may fail if the subject and the substitute do not match in client and
 * chain parameters (with exception to latest height, frozen height, and chain-id).
 *
 * @generated from message ibc.core.client.v1.ClientUpdateProposal
 */
export class ClientUpdateProposal extends Message<ClientUpdateProposal> {
  /**
   * the title of the update proposal
   *
   * @generated from field: string title = 1;
   */
  title = '';

  /**
   * the description of the proposal
   *
   * @generated from field: string description = 2;
   */
  description = '';

  /**
   * the client identifier for the client to be updated if the proposal passes
   *
   * @generated from field: string subject_client_id = 3;
   */
  subjectClientId = '';

  /**
   * the substitute client identifier for the client standing in for the subject
   * client
   *
   * @generated from field: string substitute_client_id = 4;
   */
  substituteClientId = '';

  constructor(data?: PartialMessage<ClientUpdateProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'ibc.core.client.v1.ClientUpdateProposal';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'title', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    {
      no: 2,
      name: 'description',
      kind: 'scalar',
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 3,
      name: 'subject_client_id',
      kind: 'scalar',
      T: 9 /* ScalarType.STRING */,
    },
    {
      no: 4,
      name: 'substitute_client_id',
      kind: 'scalar',
      T: 9 /* ScalarType.STRING */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): ClientUpdateProposal {
    return new ClientUpdateProposal().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): ClientUpdateProposal {
    return new ClientUpdateProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): ClientUpdateProposal {
    return new ClientUpdateProposal().fromJsonString(jsonString, options);
  }

  static equals(
    a: ClientUpdateProposal | PlainMessage<ClientUpdateProposal> | undefined,
    b: ClientUpdateProposal | PlainMessage<ClientUpdateProposal> | undefined,
  ): boolean {
    return proto3.util.equals(ClientUpdateProposal, a, b);
  }
}

/**
 * UpgradeProposal is a gov Content type for initiating an IBC breaking
 * upgrade.
 *
 * @generated from message ibc.core.client.v1.UpgradeProposal
 */
export class UpgradeProposal extends Message<UpgradeProposal> {
  /**
   * @generated from field: string title = 1;
   */
  title = '';

  /**
   * @generated from field: string description = 2;
   */
  description = '';

  /**
   * @generated from field: cosmos.upgrade.v1beta1.Plan plan = 3;
   */
  plan?: Plan;

  /**
   * An UpgradedClientState must be provided to perform an IBC breaking upgrade.
   * This will make the chain commit to the correct upgraded (self) client state
   * before the upgrade occurs, so that connecting chains can verify that the
   * new upgraded client is valid by verifying a proof on the previous version
   * of the chain. This will allow IBC connections to persist smoothly across
   * planned chain upgrades
   *
   * @generated from field: google.protobuf.Any upgraded_client_state = 4;
   */
  upgradedClientState?: Any;

  constructor(data?: PartialMessage<UpgradeProposal>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'ibc.core.client.v1.UpgradeProposal';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: 'title', kind: 'scalar', T: 9 /* ScalarType.STRING */ },
    {
      no: 2,
      name: 'description',
      kind: 'scalar',
      T: 9 /* ScalarType.STRING */,
    },
    { no: 3, name: 'plan', kind: 'message', T: Plan },
    { no: 4, name: 'upgraded_client_state', kind: 'message', T: Any },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): UpgradeProposal {
    return new UpgradeProposal().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): UpgradeProposal {
    return new UpgradeProposal().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): UpgradeProposal {
    return new UpgradeProposal().fromJsonString(jsonString, options);
  }

  static equals(
    a: UpgradeProposal | PlainMessage<UpgradeProposal> | undefined,
    b: UpgradeProposal | PlainMessage<UpgradeProposal> | undefined,
  ): boolean {
    return proto3.util.equals(UpgradeProposal, a, b);
  }
}

/**
 * Height is a monotonically increasing data type
 * that can be compared against another Height for the purposes of updating and
 * freezing clients
 *
 * Normally the RevisionHeight is incremented at each height while keeping
 * RevisionNumber the same. However some consensus algorithms may choose to
 * reset the height in certain conditions e.g. hard forks, state-machine
 * breaking changes In these cases, the RevisionNumber is incremented so that
 * height continues to be monitonically increasing even as the RevisionHeight
 * gets reset
 *
 * @generated from message ibc.core.client.v1.Height
 */
export class Height extends Message<Height> {
  /**
   * the revision that the client is currently on
   *
   * @generated from field: uint64 revision_number = 1;
   */
  revisionNumber = protoInt64.zero;

  /**
   * the height within the given revision
   *
   * @generated from field: uint64 revision_height = 2;
   */
  revisionHeight = protoInt64.zero;

  constructor(data?: PartialMessage<Height>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'ibc.core.client.v1.Height';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'revision_number',
      kind: 'scalar',
      T: 4 /* ScalarType.UINT64 */,
    },
    {
      no: 2,
      name: 'revision_height',
      kind: 'scalar',
      T: 4 /* ScalarType.UINT64 */,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Height {
    return new Height().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): Height {
    return new Height().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Height {
    return new Height().fromJsonString(jsonString, options);
  }

  static equals(
    a: Height | PlainMessage<Height> | undefined,
    b: Height | PlainMessage<Height> | undefined,
  ): boolean {
    return proto3.util.equals(Height, a, b);
  }
}

/**
 * Params defines the set of IBC light client parameters.
 *
 * @generated from message ibc.core.client.v1.Params
 */
export class Params extends Message<Params> {
  /**
   * allowed_clients defines the list of allowed client state types which can be created
   * and interacted with. If a client type is removed from the allowed clients list, usage
   * of this client will be disabled until it is added again to the list.
   *
   * @generated from field: repeated string allowed_clients = 1;
   */
  allowedClients: string[] = [];

  constructor(data?: PartialMessage<Params>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime: typeof proto3 = proto3;
  static readonly typeName = 'ibc.core.client.v1.Params';
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    {
      no: 1,
      name: 'allowed_clients',
      kind: 'scalar',
      T: 9 /* ScalarType.STRING */,
      repeated: true,
    },
  ]);

  static fromBinary(
    bytes: Uint8Array,
    options?: Partial<BinaryReadOptions>,
  ): Params {
    return new Params().fromBinary(bytes, options);
  }

  static fromJson(
    jsonValue: JsonValue,
    options?: Partial<JsonReadOptions>,
  ): Params {
    return new Params().fromJson(jsonValue, options);
  }

  static fromJsonString(
    jsonString: string,
    options?: Partial<JsonReadOptions>,
  ): Params {
    return new Params().fromJsonString(jsonString, options);
  }

  static equals(
    a: Params | PlainMessage<Params> | undefined,
    b: Params | PlainMessage<Params> | undefined,
  ): boolean {
    return proto3.util.equals(Params, a, b);
  }
}
